<!DOCTYPE html>
<html>
<link rel="apple-touch-icon" sizes="128x128" href="/html/img/Boxes51.png">
<link rel="icon" href="/html/img/Boxes51.png">

<head>
    <title>Felipe</title>
    <style>
        body {
            margin: 0;
            overflow: hidden
        }

        canvas {
            width: 100%;
            height: 100%;
            overflow: hidden
        }
    </style>
</head>

<body style="background-color:#0066ff;">
    <script src="../aa_libraries/matter.js"></script>
    <script src="../aa_libraries/p5.js"></script>
    <script>

        let cols = 7, rows = 7;
        let cellSize = 40;
        let board = [];
        let pieces = [];

        let gridOffsetX, gridOffsetY;
        var canvas;

        var TARGET_MONTH = "OCT";  // example month
        var TARGET_DAY = "13";   // example day


        function setup() {
            setTargetToToday();
            let size = min(windowWidth, windowHeight) * 0.95;
            canvas = createCanvas(size, size);
            centerCanvas();
            disableCanvasDefaults();

            // cell size is always 1/12 of canvas width
            cellSize = width / 12;

            // calculate offsets so board is centered
            gridOffsetX = (width - cols * cellSize) / 2;
            gridOffsetY = (height - rows * cellSize) / 2;

            initBoard();
            initPieces();
        }


        function draw() {
            clear();
            background(0, 0, 0, 10);

            drawBoard();
            drawPieces();

            if (checkWin()) {
                fill(0, 200, 0);
                textSize(32);
                textAlign(CENTER, CENTER);
                text("You Win!", width / 2, height / 2);
            }
        }

        function initBoard() {
            board = [];
            labels = [];
            let months = ["JAN", "FEB", "MAR", "APR", "MAY", "JUN",
                "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];

            let monthIndex = 0;
            let dayIndex = 1;

            for (let y = 0; y < rows; y++) {
                let row = [];
                let labelRow = [];
                for (let x = 0; x < cols; x++) {
                    row.push(null);

                    // skip blocked cells
                    if ((x === 6 && y === 0) || (x === 6 && y === 1) ||
                        (x === 6 && y === 6) || (x === 5 && y === 6) ||
                        (x === 4 && y === 6) || (x === 3 && y === 6)) {
                        labelRow.push(null);
                        continue;
                    }

                    let label = "";
                    if (monthIndex < months.length) {
                        label = months[monthIndex++];
                    } else if (dayIndex <= 31) {
                        label = dayIndex.toString();
                        dayIndex++;
                    }
                    labelRow.push(label);
                }
                board.push(row);
                labels.push(labelRow);
            }
        }

        function initPieces() {
            let shapes = [
                [[0, 0], [1, 0], [0, 1], [1, 1], [0, 2], [1, 2]],    // 2x3 rect
                [[0, 0], [0, 1], [0, 2], [1, 2], [2, 2]],           // 3x3 L
                [[0, 0], [1, 0], [1, 1], [1, 2], [2, 2]],           // 3x3 Z
                [[0, 0], [1, 0], [0, 1], [1, 1], [0, 2]],           // 2x3 d
                [[0, 0], [1, 0], [0, 1], [1, 2], [0, 2]],           // 2x3 U
                [[0, 0], [1, 0], [2, 0], [3, 0], [3, 1]],           // 2x4 L
                [[0, 0], [1, 0], [1, 1], [2, 1], [3, 1]],           // 2x4 Z
                [[0, 0], [1, 0], [2, 0], [3, 0], [2, 1]],           // 2x4 T
            ];



            let colors = [
                color(255, 0, 0),    // red
                color(0, 255, 0),    // green
                color(0, 0, 255),    // blue
                color(255, 165, 0),  // orange
                color(255, 0, 255),  // magenta
                color(0, 255, 255),  // cyan
                color(128, 0, 255),// pink
                color(255, 255, 0)   // yellow
            ];

            pieces = shapes.map((shape,i) => {
                // find piece dimensions in cells
                let maxX = max(shape.map(([dx, _]) => dx));
                let maxY = max(shape.map(([_, dy]) => dy));
                let w = (maxX + 1) * cellSize;
                let h = (maxY + 1) * cellSize;

                let side = floor(random(4)); // 0=top,1=right,2=bottom,3=left
                let x, y;
                if (side === 0) { // top
                    x = random(10, width - w - 10);
                    y = 10;
                } else if (side === 1) { // right
                    x = width - w - 10;
                    y = random(10, height - h - 10);
                } else if (side === 2) { // bottom
                    x = random(10, width - w - 10);
                    y = height - h - 10;
                } else { // left
                    x = 10;
                    y = random(10, height - h - 10);
                }

                let piece = new Piece(shape, x, y);
                piece.col = colors[i]
                return piece
            });
        }


        function drawBoard() {
            noStroke();
            textAlign(CENTER, CENTER);
            textSize(cellSize * 0.4);

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    let px = gridOffsetX + x * cellSize;
                    let py = gridOffsetY + y * cellSize;

                    // blocked cells gray
                    if (labels[y][x] === null) {
                        continue;
                    }

                    fill(0);
                    // highlight target cells
                    if (labels[y][x] === TARGET_MONTH || labels[y][x] === TARGET_DAY) {
                        fill("yellow")
                        text(labels[y][x], px + cellSize / 2, py + cellSize / 2);
                        continue
                    } else {
                        fill(board[y][x] ? board[y][x].col : 255);
                    }
                    rect(px, py, cellSize, cellSize);

                    // draw label
                    if (labels[y][x]) {
                        noStroke();
                        fill(0)
                        text(labels[y][x], px + cellSize / 2, py + cellSize / 2);
                    }
                }
            }
        }


        function setTargetToToday() {

            const MONTHS = ["JAN", "FEB", "MAR", "APR", "MAY", "JUN",
                "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];

            const today = new Date();
            const monthIndex = today.getMonth(); // 0 = Jan, 11 = Dec
            const day = today.getDate();         // 1-31

            TARGET_MONTH = MONTHS[monthIndex];
            TARGET_DAY = day.toString();
        }


        function drawPieces() {
            for (let piece of pieces) {
                piece.show();
            }
        }

        function mousePressed() {
            for (let i = pieces.length - 1; i >= 0; i--) {
                if (pieces[i].contains(mouseX, mouseY)) {
                    let piece = pieces.splice(i, 1)[0];
                    pieces.push(piece);
                    piece.removeFromBoard();
                    piece.dragging = true;
                    piece.offsetX = mouseX - piece.x;
                    piece.offsetY = mouseY - piece.y;
                    break;
                }
            }
        }

        function doubleTapped() {
            for (let piece of pieces) {
                if (piece.dragging) {
                    piece.rotate();
                    break;
                }
            }
        }
        let lastTap = 0;

        // --- Touch Handling ---
        function touchStarted() {
            if (touches.length === 1) {
                // One finger: pick up piece like mousePressed
                for (let i = pieces.length - 1; i >= 0; i--) {
                    if (pieces[i].contains(touches[0].x, touches[0].y)) {
                        let piece = pieces.splice(i, 1)[0];
                        pieces.push(piece);
                        piece.removeFromBoard();
                        piece.dragging = true;
                        piece.offsetX = touches[0].x - piece.x;
                        piece.offsetY = touches[0].y - piece.y;
                        break;
                    }
                }

                // Detect double-tap for rotate
                let currentTime = millis();
                if (currentTime - lastTap < 300) { // 300ms threshold
                    for (let piece of pieces) {
                        if (piece.dragging) {
                            piece.flip();
                            break;
                        }
                    }
                }
                lastTap = currentTime;
            }

            // Two-finger tap = flip
            if (touches.length === 2) {
                for (let piece of pieces) {
                    if (piece.dragging) {
                        piece.rotate();
                        break;
                    }
                }
            }
            return false; // prevent default scrolling
        }

        function touchMoved() {
            if (touches.length === 1) {
                for (let piece of pieces) {
                    if (piece.dragging) {
                        piece.x = touches[0].x - piece.offsetX;
                        piece.y = touches[0].y - piece.offsetY;
                    }
                }
            }
            return false;
        }

        function touchEnded() {
            if (touches.length === 0) {
            for (let piece of pieces) {
                if (piece.dragging) {
                    piece.dragging = false;
                    let gx = Math.round((piece.x - gridOffsetX) / cellSize);
                    let gy = Math.round((piece.y - gridOffsetY) / cellSize);
                    if (piece.canPlace(gx, gy)) {
                        piece.place(gx, gy);
                    }
                }
            }
            }
            return false;
        }



        function mouseDragged() {
            for (let piece of pieces) {
                if (piece.dragging) {
                    piece.x = mouseX - piece.offsetX;
                    piece.y = mouseY - piece.offsetY;
                }
            }
        }

        function mouseReleased() {
            for (let piece of pieces) {
                if (piece.dragging) {
                    piece.dragging = false;
                    let gx = Math.round((piece.x - gridOffsetX) / cellSize);
                    let gy = Math.round((piece.y - gridOffsetY) / cellSize);
                    if (piece.canPlace(gx, gy)) {
                        piece.place(gx, gy);
                    }
                }
            }
        }

        function keyPressed() {
            if (key === 'r' || key === 'R') {
                for (let piece of pieces) {
                    if (piece.dragging) {
                        piece.rotate();
                        break;
                    }
                }
            }

            if (key === 'f' || key === 'F') {
                for (let piece of pieces) {
                    if (piece.dragging) {
                        piece.flip();
                        break;
                    }
                }
            }
        }

        function checkWin() {
            let uncovered = [];

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (labels[y][x] === null) continue; // skip blocked
                    if (!board[y][x]) {
                        uncovered.push(labels[y][x]);
                    }
                }
            }

            // must have exactly 2 uncovered
            if (uncovered.length !== 2) return false;

            // check if they match target month/day (order doesn’t matter)
            return (uncovered.includes(TARGET_MONTH) && uncovered.includes(TARGET_DAY));
        }


        class Piece {
            constructor(shape, x, y) {
                this.shape = shape;
                this.x = x;
                this.y = y;
                this.col = color(random(50, 255), random(50, 255), random(50, 255));
                this.dragging = false;
                this.offsetX = 0;
                this.offsetY = 0;
            }

            show() {
                fill(this.col);
                strokeWeight(0.5)
                stroke(0);
                for (let [dx, dy] of this.shape) {
                    rect(this.x + dx * cellSize, this.y + dy * cellSize, cellSize, cellSize);
                }
            }

            contains(mx, my) {
                for (let [dx, dy] of this.shape) {
                    let px = this.x + dx * cellSize;
                    let py = this.y + dy * cellSize;
                    if (mx > px && mx < px + cellSize && my > py && my < py + cellSize) {
                        return true;
                    }
                }
                return false;
            }

            canPlace(gx, gy) {
                for (let [dx, dy] of this.shape) {
                    let x = gx + dx;
                    let y = gy + dy;

                    // check bounds
                    if (x < 0 || x >= cols || y < 0 || y >= rows) return false;

                    // reject blocked cells (labels[y][x] === null means blocked)
                    if (labels[y][x] === null) return false;

                    // reject already occupied
                    if (board[y][x]) return false;
                }
                return true;
            }



            place(gx, gy) {
                this.x = gridOffsetX + gx * cellSize;
                this.y = gridOffsetY + gy * cellSize;
                for (let [dx, dy] of this.shape) {
                    board[gy + dy][gx + dx] = this;
                }
            }

            removeFromBoard() {
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        if (board[y][x] === this) {
                            board[y][x] = null;
                        }
                    }
                }
            }

            rotate() {
                // rotate 90° clockwise around (0,0)
                this.shape = this.shape.map(([dx, dy]) => [dy, -dx]);

                // normalize so no negative coords remain
                let minX = Math.min(...this.shape.map(([dx]) => dx));
                let minY = Math.min(...this.shape.map(([, dy]) => dy));
                this.shape = this.shape.map(([dx, dy]) => [dx - minX, dy - minY]);
            }

            flip() {
                // flip horizontally (mirror over y-axis)
                this.shape = this.shape.map(([dx, dy]) => [-dx, dy]);

                // normalize so coords start at (0,0)
                let minX = Math.min(...this.shape.map(([dx]) => dx));
                let minY = Math.min(...this.shape.map(([, dy]) => dy));
                this.shape = this.shape.map(([dx, dy]) => [dx - minX, dy - minY]);
            }

        }

    </script>

    <script src="../aa_libraries/fj_window_library.js"></script>
    <script src="../aa_libraries/fj_games_library.js"></script>
</body>

</html>