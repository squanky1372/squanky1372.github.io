<!DOCTYPE html>
<html>
	<link rel="apple-touch-icon" sizes="128x128" href="/html/img/Boxes37.png">
	<link rel="icon" href="/html/img/Boxes37.png">
    <head>
		<title>Felipe</title>
		<style>
			body { margin: 0; overflow: hidden}
			canvas {width: 100%; height: 100%; overflow: hidden}
		</style>
	</head>
    <body style="background-color:#0066ff;">
        <!-- <script src="../aa_libraries/matter.js"></script> -->

        
		<script src="../aa_libraries/p5.js"></script>
		<script>
            var totalWidth
            var scaler
            var radius
            
            var hexes

            var score = 0

            const depth = 3
        
            var lastScore = 0
            
            //Timed mode
            var timedRoundLength = 15

            //Endless Mode
            const initialSpeed = 1000
            const endlessScaler = 0.9675
            var speed

            //Clear mode
            var startTime

            var mode = 0

			function setup() {
                let size = min(windowWidth, windowHeight) * 0.95;
  
                // Create the canvas with the calculated size
                canvas = createCanvas(size, size);
                
                // Center the canvas on the screen
                centerCanvas();
                disableCanvasDefaults()
                textAlign(CENTER, CENTER)
                textSize((size/depth)/10)

                totalWidth = width / (depth*2 -1)
                scaler = totalWidth/2
                radius = scaler

                //Reset any callback functions from the last game
                const highestId = window.setTimeout(() => {
                    for (let i = highestId; i >= 0; i--) {
                        window.clearInterval(i);
                    }
                }, 0);

                //initialize mode and score to 0
                mode = 0
                score = 0
                
                //set up the grid
                hexes = generateHexGrid(depth)

                //Set up endless mode
                hexes[1].state = -1
                hexes[1].text = "[ENDLESS]"
                hexes[1].color = [0,255,255]
                hexes[18].state = -1
                hexes[18].text = "SCORES"
                hexes[18].color = [0,255,255]
                hexes[8].state = -1
                hexes[8].text = "RULES"
                hexes[8].color = [0,255,255]

                speed = initialSpeed

                hexes[3].state = -1
                hexes[3].text = "[TIMED]"
                hexes[3].color = [255,0,255]
                hexes[10].state = -1
                hexes[10].text = "SCORES"
                hexes[10].color = [255,0,255]
                hexes[12].state = -1
                hexes[12].text = "RULES"
                hexes[12].color = [255,0,255]

                hexes[5].state = -1
                hexes[5].text = "[CLEAR]"
                hexes[5].color = [255,255,0]
                hexes[14].state = -1
                hexes[14].text = "SCORES"
                hexes[14].color = [255,255,0]
                hexes[16].state = -1
                hexes[16].text = "RULES"  
                hexes[16].color = [255,255,0]
                
                if(lastScore != 0){
                    hexes[0].text = lastScore
                }
			}

            function startEndless(){
                setTimeout(addHexagonEndless, speed)

                resetHexagonNames()

                mode = 1

            }

            function startTimed(){
                setTimeout(gameOver, 15*1000)
                resetHexagonNames()
                addHexagon()

                mode = 2

            }

            function startClear(){
                resetHexagonNames()
                hexes.forEach((hex, i) => {
                    hex.state = 1
                })
                startTime = millis()

                mode = 3

            }

            function resetHexagonNames(){
                hexes.forEach((hex, i) => {
                    hex.text = "" //i
                    hex.state = 0
                })
            }

            function gameOver(){
                alert(`You scored ${score}`)
                lastScore = score
                setup()
                return
            }

            function addHexagonEndless(){
                var found = false
                hexes.forEach((hex, i) => {
                    if(hex.state == 1){
                        found = true
                    }
                })
                if(found){
                    
                    alert(`LOSERRRR ${score}`)
                    console.log("ended")
                    lastScore = score
                    setup()
                    return
                }
                else{
                    console.log("Continue")

                    var newHexagon = addHexagon()

                    speed = speed * endlessScaler
                    console.log(speed)
                    setTimeout(addHexagonEndless, speed)
                    newHexagon.startTime = millis()
                    newHexagon.endTime = millis() + speed

                }
            }

            function addHexagon(){
                var selected = Math.floor(Math.random() * (hexes.length));
                hexes[selected].state = 1
                return hexes[selected]
            }

			function draw() {
                // scaleContent()
                push()
                translate(width/2, height/2)
                // background(100)
                fill(0)
                circle(0,0,width)
                fill(0)

                hexes.forEach((hex, i) => {
                    // circle(hex[0]*scaler, hex[1]*scaler, radius)

                    if(mode == 1 && hex.state == 1){
                        hex.size = 1- ((millis() - hex.startTime) / (hex.endTime - hex.startTime))
                    }

                    noStroke()
                    if(hex.state == 0) fill(0,0,255, 150)
                    else if(hex.state == 1) fill(255,0,0)
                    else fill(hex.color)

                    hex.size = lerp(hex.size, hex.state, 0.1)
                    hexagon(hex.x*scaler, hex.y*scaler, hex.size * 0.3*scaler/40)
                    fill(255)
                    if(hex.state == -1) fill(0)
                    text(hex.text, hex.x*scaler, hex.y*scaler)

                    noFill()
                    stroke(255)
                    hexagon(hex.x*scaler, hex.y*scaler, 0.3*scaler/40)
                })
                pop()
            }

            function lerp(start, end, amt) {
                return start + (end - start) * amt;
            }

            function getHexClicked(){
                console.log(mouseX, mouseY)
                for(var i = 0; i < hexes.length; i++){
                    var hex = hexes[i]
                    var d = dist(hex.x*scaler, hex.y*scaler, mouseX-width/2, mouseY-height/2)
                    if(d < radius) {
                        return hex
                    }
                }
                return 0
            }

            function mouseClicked(){
                // checkPosition()
            }

            function touchEnded(){
                var clickedHex = getHexClicked()
                if(clickedHex == 0) return; //If we didn't click any hex, just return
                console.log(clickedHex)

                if(mode == 0){
                    if(clickedHex.text == "[ENDLESS]"){
                        startEndless()
                        return
                    }
                    if(clickedHex.text == "[TIMED]"){
                        startTimed()
                        return
                    }
                    if(clickedHex.text == "[CLEAR]"){
                        startClear()
                        return
                    }
                }

                //ENDLESS
                if(mode == 1){
                    if(clickedHex.state == 1){
                        score++
                        clickedHex.state = 0
                    }
                    else{
                        score--
                    }
                }

                //TIMED
                if(mode == 2){
                    if(clickedHex.state == 1){
                        score++
                        clickedHex.state = 0
                        addHexagon()
                    }
                    else{
                        alert("FAIL")
                    }
                }

                //CLEAR
                if(mode == 3){
                    if(clickedHex.state == 1){
                        score++
                        clickedHex.state = 0
                    }
                    else{
                        alert("FAIL")
                    }
                    console.log(score, hexCount(depth))
                    if(score >= hexCount(depth)) {
                        score = floor(millis() - startTime) / 1000
                        alert(`Win: ${score}`)
                        lastScore = score
                        setup()
                        return
                    }
                }
                return false
            }

            function hexCount(depth){
                var count = 1
                for(var i = 0; i <= depth-1; i++){
                    count += i*6
                }
                return count
            }

            function generateHexGrid(N, radius = 1) {
                if (N < 1) return [];
                
                const hexes = [{x:0, y:0, state:0, text:"", size:1, color:[0,0,0]}]; // Center hex
                const sqrt3 = Math.sqrt(3);
                
                for (let layer = 1; layer < N; layer++) {
                    let x = layer * radius * 2;
                    let y = 0;
                    
                    for (let side = 0; side < 6; side++) {
                        for (let step = 0; step < layer; step++) {
                            hexes.push({x, y, state:0, text:"", size:-1/hexes.length, color:[0,0,0]});
                            
                            switch (side) {
                                case 0: x -= radius; y += radius * sqrt3; break;
                                case 1: x -= radius * 2; break;
                                case 2: x -= radius; y -= radius * sqrt3; break;
                                case 3: x += radius; y -= radius * sqrt3; break;
                                case 4: x += radius * 2; break;
                                case 5: x += radius; y += radius * sqrt3; break;
                            }
                        }
                    }
                }
                
                return hexes;
            }

            function hexagon(transX, transY, s) {
                // fill('rgba(255, 255, 100, .25)');
                push();
                translate(transX, transY);
                scale(s);
                beginShape();
                    vertex(-130, -75);
                    vertex(-130, 75);
                    vertex(0, 150);
                    vertex(130, 75);
                    vertex(130, -75);
                    vertex(0, -150);
                endShape(CLOSE); 
                pop();
            }

			function windowResized() {
                // Recalculate size when the window is resized
                let size = min(windowWidth, windowHeight) * 0.95;
                resizeCanvas(size, size);
                centerCanvas();
			}

            function centerCanvas() {
                // Center the canvas using CSS
                let x = (windowWidth - width) / 2;
                let y = (windowHeight - height) / 2;
                canvas.position(x, y);
            }

            function scaleContent(){
                scale(min(windowWidth, windowHeight) * 0.95 / 600)
            }

            function disableCanvasDefaults() {
                // Prevent selection and zooming via CSS
                canvas.style('touch-action', 'none'); // Disable default touch actions

                // Prevent default behaviors for double-tap and long-press
                canvas.elt.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });
                canvas.elt.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
                canvas.elt.addEventListener('touchend', (e) => e.preventDefault(), { passive: false });
            }
		</script>
    </body>
</html>